#' Plot Sampling Result
#'
#' This function plots the comparison between the theoretical target PDF
#' and the empirical distribution of the samples generated using different sampling methods.
#'
#' @param samples A numeric vector of samples generated by any of the sampling methods (e.g., Inverse CDF, Box-Muller, Accept-Reject, MCMC).
#' @param target_pdf A function representing the target probability distribution (used for comparison).
#' @param from The lower bound of the x-axis (optional).
#' @param to The upper bound of the x-axis (optional).
#' @param main The main title of the plot.
#' @examples
#' # Define target PDF (Standard Normal Distribution)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Generate samples using Inverse CDF Sampling (Exponential Distribution)
#' samples <- inverse_cdf_sampling(1000, function(u) -log(1 - u))
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
plot_sampling <- function(samples, target_pdf, from = -4, to = 4, main = "Sampling vs Theoretical PDF") {
  # Plot the target PDF (theoretical distribution)
  curve(target_pdf(x), from = from, to = to, col = "blue", lwd = 2, main = main, ylim = c(0, 1))

  # Plot the histogram of the sampled values
  hist(samples, probability = TRUE, breaks = 30, col = "lightblue", add = TRUE, density = 30, border = NA)

  # Add a legend
  legend("topright", legend = c("Target PDF", "Sampled PDF"), col = c("blue", "lightblue"), lwd = 2)
}

#------------------------------------

#' Plot Contour Plot for 2D Samples
#'
#' This function plots a contour plot of the target PDF and overlays the sampled points
#' in a 2D space, comparing the theoretical PDF and the sample distribution.
#'
#' @param samples A data frame or matrix with 2 columns representing the 2D sampled points.
#' @param target_pdf A function representing the target 2D probability distribution (used for comparison).
#' @param from The lower bound for the x-axis (optional).
#' @param to The upper bound for the x-axis (optional).
#' @param n_contour The number of contour levels.
#' @param main The title of the plot.
#' @examples
#' # Custom 2D density function
#' density <- function(x, y) {
#'   return(2 * (1 - x) * (1 - y) * (1 - x * y)^(-3))
#' }
#'
#' # Generate 2D samples using the provided sampling method
#' generate_samples <- function(n) {
#'   x_samples <- numeric(n)
#'   y_samples <- numeric(n)
#'   for (i in 1:n) {
#'     y_samples[i] <- runif(1)
#'     u <- runif(1)
#'     x_samples[i] <- (sqrt(u) - 1) / (y_samples[i] * sqrt(u) - 1)
#'   }
#'   return(data.frame(x = x_samples, y = y_samples))
#' }
#'
#' # Generate 1000 samples
#' samples_2d <- generate_samples(1000)
#'
#' # Plot the contour plot comparing the target PDF and sampled points
#' plot_2d_sampling(samples_2d, density)
#'
#' @export
plot_2d_sampling <- function(samples, target_pdf, from = 0, to = 0.99, n_contour = 30, main = "2D Sampling vs Theoretical PDF") {
  # Create a fine grid for plotting
  grid_size <- 100
  x_vals_fine <- seq(from, to, length.out = grid_size)
  y_vals_fine <- seq(from, to, length.out = grid_size)

  # Compute the target PDF on the grid
  z_matrix_fine <- matrix(0, length(x_vals_fine), length(y_vals_fine))
  for (i in 1:length(x_vals_fine)) {
    for (j in 1:length(y_vals_fine)) {
      z_matrix_fine[i, j] <- target_pdf(x_vals_fine[i], y_vals_fine[j])
    }
  }

  # Cap the values for better visualization
  z_matrix_capped <- pmin(z_matrix_fine, 5)

  # Prepare the data for plotting
  df <- expand.grid(x = x_vals_fine, y = y_vals_fine)
  df$z <- c(z_matrix_capped)

  # Plot using ggplot2
  ggplot(df, aes(x = x, y = y)) +
    geom_point(aes(size = z, color = z), alpha = 0.9) +
    scale_color_gradientn(colors = c("darkgreen", "olivedrab", "yellow", "orange", "red3")) +
    scale_size(range = c(0.5, 6)) +
    coord_cartesian(xlim = c(from, to), ylim = c(from, to)) +
    theme(legend.position = "none") +
    geom_contour(aes(x = x, y = y, z = z), color = "darkslategray", size = 0.5) +
    geom_point(data = samples, aes(x = x, y = y), alpha = 0.7, pch = 16) +
    ggtitle(main)
}


#------------------------------------

#' Inverse CDF Sampling
#'
#' This function generates random samples from a given continuous probability distribution
#' using the inverse cumulative distribution function (CDF) method.
#'
#' @param n The number of samples to generate.
#' @param inv A function representing the inverse CDF of the target distribution.
#' @return A numeric vector of sampled values.
#' @examples
#' # Define the inverse CDF for an Exponential Distribution
#' inv_cdf_exp <- function(u) { -log(1 - u) }
#'
#' # Generate 1000 samples using Inverse CDF Sampling
#' samples <- inv_cdf(inv_cdf_exp, n = 1000)
#'
#' # Plot the comparison between the exponential PDF and sampled values
#' plot_sampling(samples, function(x) dexp(x))  # Compare with exponential PDF
#'
#' @export
inv_cdf <- function(inv, n = 100000) {
  u <- runif(n)  # Generate uniform samples in (0,1)
  inv(u)     # Apply inverse CDF to transform uniform samples
}

#------------------------------------

#' Box-Muller Normal Sampling
#'
#' This function generates random samples from a standard normal distribution
#' using the Box-Muller transform.
#'
#' @param n The number of samples to generate (must be even for full pairs).
#' @return A numeric vector of sampled values from N(0,1).
#' @examples
#' # Generate 1000 samples using the Box-Muller transform
#' samples <- box_muller(1000)
#'
#' # Plot the comparison between the normal PDF and sampled values
#' plot_sampling(samples, function(x) dnorm(x))  # Compare with normal PDF
#'
#' @export
box_muller <- function(n = 100000) {
  if (n %% 2 == 1) stop("n must be even for full pairs.")

  u1 <- runif(n / 2)
  u2 <- runif(n / 2)

  r <- sqrt(-2 * log(u1))
  theta <- 2 * pi * u2

  z1 <- r * cos(theta)
  z2 <- r * sin(theta)

  return(c(z1, z2))  # Return the combined vector of normal samples
}



#------------------------------------

#' Accept-Reject Sampling with Efficiency Calculation
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method and calculates both the **theoretical**
#' and **empirical efficiency**.
#'
#' @param proposal A function representing the probability density function (PDF) of the proposal distribution.
#' @param target A function representing the probability density function (PDF) of the target distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A list containing:
#'   - `samples`: A numeric vector of accepted samples.
#'   - `theoretical_efficiency`: Theoretical efficiency (acceptance probability).
#'   - `empirical_efficiency`: Empirical efficiency (based on actual samples).
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Perform Accept-Reject Sampling with efficiency calculation
#' result <- accept_reject(proposal_pdf, target_pdf,
#'                                   M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(result$samples, target_pdf)
#'
#' # Print the theoretical efficiency (acceptance probability)
#' result$theoretical_efficiency
#'
#' # Print the empirical efficiency (based on actual samples)
#' result$empirical_efficiency
#'
#' @export
accept_reject <- function(proposal, target, M, n=100000) {
  samples <- numeric(n)
  count <- 0  # Counter for accepted samples
  total_proposed <- 0  # Counter for proposed samples

  while (count < n) {
    x <- proposal(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample
    total_proposed <- total_proposed + 1

    if (u <= target(x) / (M * proposal(x))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  # Theoretical efficiency: ratio of acceptance probabilities
  theoretical_efficiency <- 1/M

  # Empirical efficiency: ratio of accepted samples to proposed samples
  empirical_efficiency <- n / total_proposed

  return(list(samples = samples,
              theoretical_efficiency = theoretical_efficiency,
              empirical_efficiency = empirical_efficiency))
}



#------------------------------------
#' Metropolis Algorithm (Supports Optional Metropolis-Hastings)
#'
#' This function implements the Metropolis algorithm for sampling from a given target distribution.
#' Currently, Metropolis-Hastings is not implemented, but the function structure allows future extension.
#'
#' @param target A function representing the target distribution (unnormalized density).
#' @param initial A function that generates the initial sample.
#' @param proposal A function that proposes a new sample given the current sample.
#' @param n Integer, number of iterations for the algorithm. Default is 100000.
#' @param hastings Logical, whether to use Metropolis-Hastings. Currently, only Metropolis is implemented. Default is FALSE.
#'
#' @return A list containing the sampled values.
#'
#' @examples
#' # Define target distribution (unnormalized density)
#' target <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Define proposal function (Normal random walk)
#' proposal <- function(x) { rnorm(1, mean = x, sd = 1) }
#'
#' # Define initial value function
#' initial <- function() { 0 }
#'
#' # Run Metropolis algorithm
#' samples <- metropolis(target, initial, proposal, n = 10000, hastings = FALSE)
#'
#' # Plot the histogram of samples
#' hist(unlist(samples), probability = TRUE, main = "Metropolis Samples",
#'      xlab = "x", col = "lightblue", border = "black")
#'
#' @export
metropolis <- function(target, initial, proposal, n = 100000, hastings = FALSE){
  samples <- list(initial())

  for (i in 1:n) {
    current <- samples[[length(samples)]]
    proposed <- proposal(current)

    if (hastings == FALSE){
      if (runif(1) < target(proposed) / target(current)) {
        samples <- append(samples, list(proposed))
      } else {
        samples <- append(samples, list(current))
      }

    }

    if (hastings == TRUE){
      NULL
    }
  }

  return(samples)

}

