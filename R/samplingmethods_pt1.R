#' Plot Sampling Result
#'
#' This function plots the comparison between the theoretical target PDF
#' and the empirical distribution of the samples generated using different sampling methods.
#'
#' @param samples A numeric vector of samples generated by any of the sampling methods (e.g., Inverse CDF, Box-Muller, Accept-Reject, MCMC).
#' @param target_pdf A function representing the target probability distribution (used for comparison).
#' @param from The lower bound of the x-axis (optional).
#' @param to The upper bound of the x-axis (optional).
#' @param main The main title of the plot.
#' @examples
#' # Define target PDF (Standard Normal Distribution)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Generate samples using Inverse CDF Sampling (Exponential Distribution)
#' samples <- inverse_cdf_sampling(1000, function(u) -log(1 - u))
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
plot_sampling <- function(samples, target_pdf, from = -4, to = 4, main = "Sampling vs Theoretical PDF") {
  # Plot the target PDF (theoretical distribution)
  curve(target_pdf(x), from = from, to = to, col = "blue", lwd = 2, main = main, ylim = c(0, 1))

  # Plot the histogram of the sampled values
  hist(samples, probability = TRUE, breaks = 30, col = "lightblue", add = TRUE, density = 30, border = NA)

  # Add a legend
  legend("topright", legend = c("Target PDF", "Sampled PDF"), col = c("blue", "lightblue"), lwd = 2)
}

#------------------------------------

#' Plot 3D Contour Plot for 2D Samples
#'
#' This function plots a 3D contour plot to compare the target PDF and sampled values
#' in a 2D space (for methods like Gibbs or Metropolis with 2D sampling).
#'
#' @param samples A numeric matrix or data frame with 2 columns representing the 2D sampled points.
#' @param target_pdf A function representing the target 2D probability distribution (used for comparison).
#' @param from The lower bound for the x-axis (optional).
#' @param to The upper bound for the x-axis (optional).
#' @param n_contour The number of contour levels.
#' @param main The title of the plot.
#' @examples
#' # Define target 2D PDF (Standard Normal Distribution in both X and Y)
#' target_pdf_2d <- function(x, y) { dnorm(x, mean = 0, sd = 1) * dnorm(y, mean = 0, sd = 1) }
#'
#' # Generate 2D samples (e.g., from a Normal distribution)
#' samples_2d <- matrix(c(rnorm(1000), rnorm(1000)), ncol = 2)
#'
#' # Plot the 3D contour plot comparing the target PDF and sampled points
#' plot_2d_sampling(samples_2d, target_pdf_2d)
#'
#' @export
plot_2d_sampling <- function(samples, target_pdf, from = -4, to = 4, n_contour = 30, main = "2D Sampling vs Theoretical PDF") {
  # Create a grid for plotting
  grid_size <- 100
  x_vals <- seq(from, to, length.out = grid_size)
  y_vals <- seq(from, to, length.out = grid_size)
  grid <- expand.grid(x = x_vals, y = y_vals)

  # Compute the target PDF on the grid
  z_vals <- matrix(mapply(target_pdf, grid$x, grid$y), ncol = grid_size)

  # Create 3D contour plot
  persp(x_vals, y_vals, z_vals, theta = 30, phi = 30, col = "lightblue", border = "white",
        xlab = "X", ylab = "Y", zlab = "Density", main = main, shade = 0.5)

  # Add points for sampled data (empirical distribution)
  points(samples[, 1], samples[, 2], col = rgb(1, 0, 0, alpha = 0.5), pch = 16)
}

#------------------------------------

#' Inverse CDF Sampling
#'
#' This function generates random samples from a given continuous probability distribution
#' using the inverse cumulative distribution function (CDF) method.
#'
#' @param n The number of samples to generate.
#' @param inv_cdf A function representing the inverse CDF of the target distribution.
#' @return A numeric vector of sampled values.
#' @examples
#' # Define the inverse CDF for an Exponential Distribution
#' inv_cdf_exp <- function(u) { -log(1 - u) }
#'
#' # Generate 1000 samples using Inverse CDF Sampling
#' samples <- inverse_cdf_sampling(1000, inv_cdf_exp)
#'
#' # Plot the comparison between the exponential PDF and sampled values
#' plot_sampling(samples, function(x) dexp(x))  # Compare with exponential PDF
#'
#' @export
inverse_cdf_sampling <- function(n, inv_cdf) {
  u <- runif(n)  # Generate uniform samples in (0,1)
  inv_cdf(u)     # Apply inverse CDF to transform uniform samples
}

#------------------------------------

#' Box-Muller Normal Sampling
#'
#' This function generates random samples from a standard normal distribution
#' using the Box-Muller transform.
#'
#' @param n The number of samples to generate (must be even for full pairs).
#' @return A numeric vector of sampled values from N(0,1).
#' @examples
#' # Generate 1000 samples using the Box-Muller transform
#' samples <- box_muller_sampling(1000)
#'
#' # Plot the comparison between the normal PDF and sampled values
#' plot_sampling(samples, function(x) dnorm(x))  # Compare with normal PDF
#'
#' @export
box_muller_sampling <- function(n) {
  if (n %% 2 == 1) stop("n must be even for full pairs.")

  u1 <- runif(n / 2)
  u2 <- runif(n / 2)

  r <- sqrt(-2 * log(u1))
  theta <- 2 * pi * u2

  z1 <- r * cos(theta)
  z2 <- r * sin(theta)

  c(z1, z2)  # Return the combined vector of normal samples
}

#------------------------------------

#' Accept-Reject Sampling
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method.
#'
#' @param proposal_pdf A function representing the probability density function (PDF) of the proposal distribution.
#' @param target_pdf A function representing the probability density function (PDF) of the target distribution.
#' @param proposal_sample A function that generates random samples from the proposal distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A numeric vector of accepted samples.
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Generate 1000 samples using Accept-Reject Sampling
#' samples <- accept_reject_sampling(proposal_pdf, target_pdf, function(n) runif(n, -3, 3), M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
accept_reject_sampling <- function(proposal_pdf, target_pdf, proposal_sample, M, n) {
  samples <- numeric(n)
  count <- 0  # Counter for accepted samples

  while (count < n) {
    x <- proposal_sample(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample

    if (u <= target_pdf(x) / (M * proposal_pdf(x))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  samples
}

#------------------------------------

#' Accept-Reject Sampling with Efficiency Calculation
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method and calculates both the **theoretical**
#' and **empirical efficiency**.
#'
#' @param proposal_pdf A function representing the probability density function (PDF) of the proposal distribution.
#' @param target_pdf A function representing the probability density function (PDF) of the target distribution.
#' @param proposal_sample A function that generates random samples from the proposal distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A list containing:
#'   - `samples`: A numeric vector of accepted samples.
#'   - `theoretical_efficiency`: Theoretical efficiency (acceptance probability).
#'   - `empirical_efficiency`: Empirical efficiency (based on actual samples).
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Perform Accept-Reject Sampling with efficiency calculation
#' result <- accept_reject_sampling(proposal_pdf, target_pdf,
#'                                  function(n) runif(n, -3, 3), M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(result$samples, target_pdf)
#'
#' # Print the theoretical efficiency (acceptance probability)
#' result$theoretical_efficiency
#'
#' # Print the empirical efficiency (based on actual samples)
#' result$empirical_efficiency
#'
#' @export
accept_reject_sampling <- function(proposal_pdf, target_pdf, proposal_sample, M, n) {
  samples <- numeric(n)
  count <- 0  # Counter for accepted samples
  total_proposed <- 0  # Counter for proposed samples

  while (count < n) {
    x <- proposal_sample(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample
    total_proposed <- total_proposed + 1

    if (u <= target_pdf(x) / (M * proposal_pdf(x))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  # Theoretical efficiency: ratio of acceptance probabilities
  theoretical_efficiency <- mean(target_pdf(seq(-3, 3, length.out = 100)) / (M * proposal_pdf(seq(-3, 3, length.out = 100))))

  # Empirical efficiency: ratio of accepted samples to proposed samples
  empirical_efficiency <- n / total_proposed

  return(list(samples = samples,
              theoretical_efficiency = theoretical_efficiency,
              empirical_efficiency = empirical_efficiency))
}
