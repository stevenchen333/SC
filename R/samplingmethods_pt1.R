#' Plot Sampling Result
#'
#' This function plots the comparison between the theoretical target PDF
#' and the empirical distribution of the samples generated using different sampling methods.
#'
#' @param samples A numeric vector of samples generated by any of the sampling methods (e.g., Inverse CDF, Box-Muller, Accept-Reject, MCMC).
#' @param target_pdf A function representing the target probability distribution (used for comparison).
#' @param from The lower bound of the x-axis (optional).
#' @param to The upper bound of the x-axis (optional).
#' @param main The main title of the plot.
#' @examples
#' # Define target PDF (Standard Normal Distribution)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Generate samples using Inverse CDF Sampling (Exponential Distribution)
#' samples <- inverse_cdf_sampling(1000, function(u) -log(1 - u))
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
plot_sampling <- function(samples, target_pdf, from = -4, to = 4, main = "Sampling vs Theoretical PDF") {
  # Plot the target PDF (theoretical distribution)
  curve(target_pdf(x), from = from, to = to, col = "blue", lwd = 2, main = main, ylim = c(0, 1))

  # Plot the histogram of the sampled values
  hist(samples, probability = TRUE, breaks = 30, col = "lightblue", add = TRUE, density = 30, border = NA)

  # Add a legend
  legend("topright", legend = c("Target PDF", "Sampled PDF"), col = c("blue", "lightblue"), lwd = 2)
}

#------------------------------------

#' Plot Contour Plot for 2D Samples
#'
#' This function plots a contour plot of the target PDF and overlays the sampled points
#' in a 2D space, comparing the theoretical PDF and the sample distribution.
#'
#' @param samples A data frame or matrix with 2 columns representing the 2D sampled points.
#' @param target_pdf A function representing the target 2D probability distribution (used for comparison).
#' @param from The lower bound for the x-axis (optional).
#' @param to The upper bound for the x-axis (optional).
#' @param n_contour The number of contour levels.
#' @param main The title of the plot.
#' @examples
#' # Custom 2D density function
#' density <- function(x, y) {
#'   return(2 * (1 - x) * (1 - y) * (1 - x * y)^(-3))
#' }
#'
#' # Generate 2D samples using the provided sampling method
#' generate_samples <- function(n) {
#'   x_samples <- numeric(n)
#'   y_samples <- numeric(n)
#'   for (i in 1:n) {
#'     y_samples[i] <- runif(1)
#'     u <- runif(1)
#'     x_samples[i] <- (sqrt(u) - 1) / (y_samples[i] * sqrt(u) - 1)
#'   }
#'   return(data.frame(x = x_samples, y = y_samples))
#' }
#'
#' # Generate 1000 samples
#' samples_2d <- generate_samples(1000)
#'
#' # Plot the contour plot comparing the target PDF and sampled points
#' plot_2d_sampling(samples_2d, density)
#'
#' @export
plot_2d_sampling <- function(samples, target_pdf, from = 0, to = 0.99, n_contour = 30, main = "2D Sampling vs Theoretical PDF") {
  # Create a fine grid for plotting
  grid_size <- 100
  x_vals_fine <- seq(from, to, length.out = grid_size)
  y_vals_fine <- seq(from, to, length.out = grid_size)

  # Compute the target PDF on the grid
  z_matrix_fine <- matrix(0, length(x_vals_fine), length(y_vals_fine))
  for (i in 1:length(x_vals_fine)) {
    for (j in 1:length(y_vals_fine)) {
      z_matrix_fine[i, j] <- target_pdf(x_vals_fine[i], y_vals_fine[j])
    }
  }

  # Cap the values for better visualization
  z_matrix_capped <- pmin(z_matrix_fine, 5)

  # Prepare the data for plotting
  df <- expand.grid(x = x_vals_fine, y = y_vals_fine)
  df$z <- c(z_matrix_capped)

  # Plot using ggplot2
  ggplot(df, aes(x = x, y = y)) +
    geom_point(aes(size = z, color = z), alpha = 0.9) +
    scale_color_gradientn(colors = c("darkgreen", "olivedrab", "yellow", "orange", "red3")) +
    scale_size(range = c(0.5, 6)) +
    coord_cartesian(xlim = c(from, to), ylim = c(from, to)) +
    theme(legend.position = "none") +
    geom_contour(aes(x = x, y = y, z = z), color = "darkslategray", size = 0.5) +
    geom_point(data = samples, aes(x = x, y = y), alpha = 0.7, pch = 16) +
    ggtitle(main)
}


#------------------------------------

#' Inverse CDF Sampling
#'
#' This function generates random samples from a given continuous probability distribution
#' using the inverse cumulative distribution function (CDF) method.
#'
#' @param n The number of samples to generate.
#' @param inv A function representing the inverse CDF of the target distribution.
#' @return A numeric vector of sampled values.
#' @examples
#' # Define the inverse CDF for an Exponential Distribution
#' inv_cdf_exp <- function(u) { -log(1 - u) }
#'
#' # Generate 1000 samples using Inverse CDF Sampling
#' samples <- inv_cdf(inv_cdf_exp, n = 1000)
#'
#' # Plot the comparison between the exponential PDF and sampled values
#' plot_sampling(samples, function(x) dexp(x))  # Compare with exponential PDF
#'
#' @export
inv_cdf <- function(inv, n = 100000) {
  u <- runif(n)  # Generate uniform samples in (0,1)
  inv(u)     # Apply inverse CDF to transform uniform samples
}

#------------------------------------

#' Box-Muller Normal Sampling
#'
#' This function generates random samples from a standard normal distribution
#' using the Box-Muller transform.
#'
#' @param n The number of samples to generate (must be even for full pairs).
#' @return A numeric vector of sampled values from N(0,1).
#' @examples
#' # Generate 1000 samples using the Box-Muller transform
#' samples <- box_muller(1000)
#'
#' # Plot the comparison between the normal PDF and sampled values
#' plot_sampling(samples, function(x) dnorm(x))  # Compare with normal PDF
#'
#' @export
box_muller <- function(n = 100000) {
  if (n %% 2 == 1) stop("n must be even for full pairs.")

  u1 <- runif(n / 2)
  u2 <- runif(n / 2)

  r <- sqrt(-2 * log(u1))
  theta <- 2 * pi * u2

  z1 <- r * cos(theta)
  z2 <- r * sin(theta)

  return(c(z1, z2))  # Return the combined vector of normal samples
}



#------------------------------------

#' General-Purpose Rejection Sampling
#'
#' @description Samples from arbitrary univariate or bivariate target distributions using rejection sampling.
#'
#' @param target Target density function (univariate: `function(x)`, bivariate: `function(c(x,y))`)
#' @param proposal Proposal density function matching `target`'s dimension
#' @param proposal_gen Function generating proposal samples (`function(n)`)
#' @param n_samples Number of samples to generate (default: 1)
#' @param bounds Support bounds for target (length 2 vector for univariate, matrix with 2 columns for bivariate)
#' @param M Optional bound for target/proposal ratio (will calculate if NULL)
#' @param max_attempts Maximum sampling attempts before stopping (default: 10,000)
#'
#' @return A list containing:
#' \itemize{
#'   \item `samples`: Matrix of accepted samples (n_samples rows Ã— dimension columns)
#'   \item `acceptance_rate`: Empirical acceptance probability
#'   \item `M`: Used bound value
#' }
#'
#' @export
#'
#' @examples
#' # Univariate example: Sampling from Gamma(3,2) using Normal(1.5,1) proposal
#' target <- function(x) dgamma(x, shape=3, rate=2)
#' proposal <- function(x) dnorm(x, mean=1.5, sd=1)
#' proposal_gen <- function(n) rnorm(n, mean=1.5, sd=1)
#'
#' result <- rejection_sample(
#'   target = target,
#'   proposal = proposal,
#'   proposal_gen = proposal_gen,
#'   bounds = c(0, Inf),
#'   n_samples = 1000
#' )
#' hist(result$samples, breaks=30, main="Gamma(3,2) Samples")
#'
#' # Bivariate example: Sampling from custom 2D density
#' target2d <- function(x) exp(-x[1]^2/2 - x[2]^2/2 - x[1]*x[2]/2)
#' proposal2d <- function(x) dnorm(x[1]) * dnorm(x[2])
#' proposal_gen2d <- function(n) matrix(rnorm(2*n), ncol=2)
#'
#' result2d <- rejection_sample(
#'   target = target2d,
#'   proposal = proposal2d,
#'   proposal_gen = proposal_gen2d,
#'   bounds = matrix(c(-3,3,-3,3), ncol=2),
#'   n_samples = 500
#' )
#' plot(result2d$samples, pch=20, main="Bivariate Samples")
rejection_sample <- function(target, proposal, proposal_gen,
                             n_samples = 1, bounds = c(-Inf, Inf),
                             M = NULL, max_attempts = 10000) {

  # Validate bounds
  if (is.matrix(bounds)) {
    if (ncol(bounds) != 2) stop("Bivariate bounds need 2 columns")
    dim <- 2
  } else {
    if (length(bounds) != 2) stop("Univariate bounds need length 2")
    dim <- 1
    bounds <- matrix(bounds, ncol=1)
  }

  # Calculate M if not provided
  if (is.null(M)) {
    ratio <- function(x) {
      if (dim == 1) {
        x <- x[1]
        if (x < bounds[1,1] || x > bounds[1,2]) return(0)
        target_val <- target(x)
        proposal_val <- proposal(x)
      } else {
        if (x[1] < bounds[1,1] || x[1] > bounds[1,2] ||
            x[2] < bounds[2,1] || x[2] > bounds[2,2]) return(0)
        target_val <- target(x)
        proposal_val <- proposal(x)
      }
      if (proposal_val <= 0) return(0)
      target_val/proposal_val
    }

    # Optimize separately for each dimension if bivariate
    if (dim == 1) {
      M <- optimize(ratio, interval = bounds[,1], maximum = TRUE)$objective
    } else {
      M <- max(
        optim(c(0,0), fn = ratio, control = list(fnscale=-1))$value,
        optim(c(1,1), fn = ratio, control = list(fnscale=-1))$value,
        optim(c(-1,1), fn = ratio, control = list(fnscale=-1))$value
      )
    }
    if (M <= 0) stop("Failed to find valid M bound")
  }

  # Sampling loop
  samples <- matrix(nrow = n_samples, ncol = dim)
  attempts <- 0
  accepted <- 0

  while (accepted < n_samples && attempts < max_attempts) {
    attempts <- attempts + 1

    # Generate proposal
    x <- proposal_gen(1)
    if (dim == 1) x <- x[1]  # Ensure scalar for univariate case

    # Check bounds
    in_bounds <- if (dim == 1) {
      x >= bounds[1,1] && x <= bounds[1,2]
    } else {
      all(x >= bounds[,1]) && all(x <= bounds[,2])
    }

    if (in_bounds) {
      u <- runif(1)
      target_val <- target(x)
      proposal_val <- if (dim == 1) proposal(x) else proposal(x)

      if (u <= target_val/(M * proposal_val)) {
        accepted <- accepted + 1
        samples[accepted,] <- x
      }
    }
  }

  if (accepted < n_samples) {
    warning(paste("Only", accepted, "samples accepted after", attempts, "attempts"))
  }

  return(list(
    samples = samples,
    acceptance_rate = accepted/attempts,
    M = M
  ))
}


#------------------------------------
#' Metropolis Algorithm (Supports Optional Metropolis-Hastings)
#'
#' This function implements the Metropolis algorithm for sampling from a given target distribution.
#' Currently, Metropolis-Hastings is not implemented, but the function structure allows future extension.
#'
#' @param target A function representing the target distribution (unnormalized density).
#' @param initial A function that generates the initial sample.
#' @param proposal A function that proposes a new sample given the current sample.
#' @param n Integer, number of iterations for the algorithm. Default is 100000.
#' @param hastings Logical, whether to use Metropolis-Hastings. Currently, only Metropolis is implemented. Default is FALSE.
#'
#' @return A list containing the sampled values.
#'
#' @examples
#' # Define target distribution (unnormalized density)
#' target <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Define proposal function (Normal random walk)
#' proposal <- function(x) { rnorm(1, mean = x, sd = 1) }
#'
#' # Define initial value function
#' initial <- function() { 0 }
#'
#' # Run Metropolis algorithm
#' samples <- metropolis(target, initial, proposal, n = 10000, hastings = FALSE)
#'
#' # Plot the histogram of samples
#' hist(unlist(samples), probability = TRUE, main = "Metropolis Samples",
#'      xlab = "x", col = "lightblue", border = "black")
#'
#' @export
metropolis <- function(target, initial, proposal, n = 100000, hastings = FALSE){
  samples <- list(initial())

  for (i in 1:n) {
    current <- samples[[length(samples)]]
    proposed <- proposal(current)

    if (hastings == FALSE){
      if (runif(1) < target(proposed) / target(current)) {
        samples <- append(samples, list(proposed))
      } else {
        samples <- append(samples, list(current))
      }

    }

    if (hastings == TRUE){
      NULL
    }
  }

  return(samples)

}

#------------------------------------
#' Flexible Gibbs Sampling with Optional Rejection Steps
#'
#' @description General-purpose Gibbs sampler supporting both direct sampling and rejection sampling steps.
#'
#' @param conditional_samplers List of conditional samplers (functions or specifications)
#' @param init Initial parameter vector
#' @param n_iter Total iterations (default: 1000)
#' @param burn_in Burn-in period (default: 100)
#' @param thinning Thinning interval (default: 1)
#'
#' @return Matrix where rows are samples and columns are parameters
#'
#' @export
#'
#' @examples
#' # Bivariate normal example
#' sampler <- list(
#'   function(y) rnorm(1, 0.5*y, sqrt(0.75)),
#'   function(x) rnorm(1, 0.5*x, sqrt(0.75))
#' )
#' samples <- gibbs_sampler(sampler, init = c(0,0))
gibbs_sampler <- function(conditional_samplers, init, n_iter = 1000, burn_in = 100, thinning = 1) {

  # Input validation
  if (length(conditional_samplers) != length(init)) {
    stop("Length of conditional_samplers must match init vector length")
  }

  n_params <- length(conditional_samplers)
  samples <- matrix(NA, nrow = n_iter, ncol = n_params)
  samples[1,] <- init

  for (i in 2:n_iter) {
    current <- samples[i-1,]

    for (j in 1:n_params) {
      cond_sampler <- conditional_samplers[[j]]

      if (is.function(cond_sampler)) {
        # Direct sampling case
        current[j] <- cond_sampler(current[-j])
      } else if (is.list(cond_sampler) && cond_sampler$method == "rejection") {
        # Rejection sampling case
        current[j] <- rejection_sampler(
          target = function(x) cond_sampler$target(x, current[-j]),
          proposal = cond_sampler$proposal,
          proposal_gen = cond_sampler$proposal_gen,
          bounds = cond_sampler$bounds
        )$samples[1]
      } else {
        stop("Invalid sampler specification for parameter ", j)
      }
    }

    samples[i,] <- current
  }

  # Apply burn-in and thinning
  keep <- seq(burn_in + 1, n_iter, by = thinning)
  return(samples[keep,])
}




