#' Plot Sampling Result
#'
#' This function plots the comparison between the theoretical target PDF
#' and the empirical distribution of the samples generated using different sampling methods.
#'
#' @param samples A numeric vector of samples generated by any of the sampling methods (e.g., Inverse CDF, Box-Muller, Accept-Reject, MCMC).
#' @param target_pdf A function representing the target probability distribution (used for comparison).
#' @param from The lower bound of the x-axis (optional).
#' @param to The upper bound of the x-axis (optional).
#' @param main The main title of the plot.
#' @examples
#' # Define target PDF (Standard Normal Distribution)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Generate samples using Inverse CDF Sampling (Exponential Distribution)
#' samples <- inverse_cdf_sampling(1000, function(u) -log(1 - u))
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
plot_sampling <- function(samples, target_pdf, from = -4, to = 4, main = "Sampling vs Theoretical PDF") {
  # Plot the target PDF (theoretical distribution)
  curve(target_pdf(x), from = from, to = to, col = "blue", lwd = 2, main = main, ylim = c(0, 1))

  # Plot the histogram of the sampled values
  hist(samples, probability = TRUE, breaks = 30, col = "lightblue", add = TRUE, density = 30, border = NA)

  # Add a legend
  legend("topright", legend = c("Target PDF", "Sampled PDF"), col = c("blue", "lightblue"), lwd = 2)
}

#------------------------------------

#' Plot Contour Plot for 2D Samples
#'
#' This function plots a contour plot of the target PDF and overlays the sampled points
#' in a 2D space, comparing the theoretical PDF and the sample distribution.
#'
#' @param samples A data frame or matrix with 2 columns representing the 2D sampled points.
#' @param target_pdf A function representing the target 2D probability distribution (used for comparison).
#' @param from The lower bound for the x-axis (optional).
#' @param to The upper bound for the x-axis (optional).
#' @param n_contour The number of contour levels.
#' @param main The title of the plot.
#' @examples
#' # Custom 2D density function
#' density <- function(x, y) {
#'   return(2 * (1 - x) * (1 - y) * (1 - x * y)^(-3))
#' }
#'
#' # Generate 2D samples using the provided sampling method
#' generate_samples <- function(n) {
#'   x_samples <- numeric(n)
#'   y_samples <- numeric(n)
#'   for (i in 1:n) {
#'     y_samples[i] <- runif(1)
#'     u <- runif(1)
#'     x_samples[i] <- (sqrt(u) - 1) / (y_samples[i] * sqrt(u) - 1)
#'   }
#'   return(data.frame(x = x_samples, y = y_samples))
#' }
#'
#' # Generate 1000 samples
#' samples_2d <- generate_samples(1000)
#'
#' # Plot the contour plot comparing the target PDF and sampled points
#' plot_2d_sampling(samples_2d, density)
#'
#' @export
plot_2d_sampling <- function(samples, target_pdf, from = 0, to = 0.99, n_contour = 30, main = "2D Sampling vs Theoretical PDF") {
  # Create a fine grid for plotting
  grid_size <- 100
  x_vals_fine <- seq(from, to, length.out = grid_size)
  y_vals_fine <- seq(from, to, length.out = grid_size)

  # Compute the target PDF on the grid
  z_matrix_fine <- matrix(0, length(x_vals_fine), length(y_vals_fine))
  for (i in 1:length(x_vals_fine)) {
    for (j in 1:length(y_vals_fine)) {
      z_matrix_fine[i, j] <- target_pdf(x_vals_fine[i], y_vals_fine[j])
    }
  }

  # Cap the values for better visualization
  z_matrix_capped <- pmin(z_matrix_fine, 5)

  # Prepare the data for plotting
  df <- expand.grid(x = x_vals_fine, y = y_vals_fine)
  df$z <- c(z_matrix_capped)

  # Plot using ggplot2
  ggplot(df, aes(x = x, y = y)) +
    geom_point(aes(size = z, color = z), alpha = 0.9) +
    scale_color_gradientn(colors = c("darkgreen", "olivedrab", "yellow", "orange", "red3")) +
    scale_size(range = c(0.5, 6)) +
    coord_cartesian(xlim = c(from, to), ylim = c(from, to)) +
    theme(legend.position = "none") +
    geom_contour(aes(x = x, y = y, z = z), color = "darkslategray", size = 0.5) +
    geom_point(data = samples, aes(x = x, y = y), alpha = 0.7, pch = 16) +
    ggtitle(main)
}


#------------------------------------

#' Inverse CDF Sampling
#'
#' This function generates random samples from a given continuous probability distribution
#' using the inverse cumulative distribution function (CDF) method.
#'
#' @param n The number of samples to generate.
#' @param inv_cdf A function representing the inverse CDF of the target distribution.
#' @return A numeric vector of sampled values.
#' @examples
#' # Define the inverse CDF for an Exponential Distribution
#' inv_cdf_exp <- function(u) { -log(1 - u) }
#'
#' # Generate 1000 samples using Inverse CDF Sampling
#' samples <- inverse_cdf_sampling(1000, inv_cdf_exp)
#'
#' # Plot the comparison between the exponential PDF and sampled values
#' plot_sampling(samples, function(x) dexp(x))  # Compare with exponential PDF
#'
#' @export
inverse_cdf_sampling <- function(n, inv_cdf) {
  u <- runif(n)  # Generate uniform samples in (0,1)
  inv_cdf(u)     # Apply inverse CDF to transform uniform samples
}

#------------------------------------

#' Box-Muller Normal Sampling
#'
#' This function generates random samples from a standard normal distribution
#' using the Box-Muller transform.
#'
#' @param n The number of samples to generate (must be even for full pairs).
#' @return A numeric vector of sampled values from N(0,1).
#' @examples
#' # Generate 1000 samples using the Box-Muller transform
#' samples <- box_muller_sampling(1000)
#'
#' # Plot the comparison between the normal PDF and sampled values
#' plot_sampling(samples, function(x) dnorm(x))  # Compare with normal PDF
#'
#' @export
box_muller_sampling <- function(n) {
  if (n %% 2 == 1) stop("n must be even for full pairs.")

  u1 <- runif(n / 2)
  u2 <- runif(n / 2)

  r <- sqrt(-2 * log(u1))
  theta <- 2 * pi * u2

  z1 <- r * cos(theta)
  z2 <- r * sin(theta)

  c(z1, z2)  # Return the combined vector of normal samples
}

#------------------------------------

#' Accept-Reject Sampling
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method.
#'
#' @param proposal_pdf A function representing the probability density function (PDF) of the proposal distribution.
#' @param target_pdf A function representing the probability density function (PDF) of the target distribution.
#' @param proposal_sample A function that generates random samples from the proposal distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A numeric vector of accepted samples.
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Generate 1000 samples using Accept-Reject Sampling
#' samples <- accept_reject_sampling(proposal_pdf, target_pdf, function(n) runif(n, -3, 3), M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
accept_reject_sampling <- function(proposal_pdf, target_pdf, proposal_sample, M, n) {
  samples <- numeric(n)
  count <- 0  # Counter for accepted samples

  while (count < n) {
    x <- proposal_sample(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample

    if (u <= target_pdf(x) / (M * proposal_pdf(x))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  samples
}

#------------------------------------

#' Accept-Reject Sampling with Efficiency Calculation
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method and calculates both the **theoretical**
#' and **empirical efficiency**.
#'
#' @param proposal_pdf A function representing the probability density function (PDF) of the proposal distribution.
#' @param target_pdf A function representing the probability density function (PDF) of the target distribution.
#' @param proposal_sample A function that generates random samples from the proposal distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A list containing:
#'   - `samples`: A numeric vector of accepted samples.
#'   - `theoretical_efficiency`: Theoretical efficiency (acceptance probability).
#'   - `empirical_efficiency`: Empirical efficiency (based on actual samples).
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Perform Accept-Reject Sampling with efficiency calculation
#' result <- accept_reject_sampling(proposal_pdf, target_pdf,
#'                                  function(n) runif(n, -3, 3), M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(result$samples, target_pdf)
#'
#' # Print the theoretical efficiency (acceptance probability)
#' result$theoretical_efficiency
#'
#' # Print the empirical efficiency (based on actual samples)
#' result$empirical_efficiency
#'
#' @export
accept_reject_sampling <- function(proposal_pdf, target_pdf, proposal_sample, M, n) {
  samples <- numeric(n)
  count <- 0  # Counter for accepted samples
  total_proposed <- 0  # Counter for proposed samples

  while (count < n) {
    x <- proposal_sample(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample
    total_proposed <- total_proposed + 1

    if (u <= target_pdf(x) / (M * proposal_pdf(x))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  # Theoretical efficiency: ratio of acceptance probabilities
  theoretical_efficiency <- mean(target_pdf(seq(-3, 3, length.out = 100)) / (M * proposal_pdf(seq(-3, 3, length.out = 100))))

  # Empirical efficiency: ratio of accepted samples to proposed samples
  empirical_efficiency <- n / total_proposed

  return(list(samples = samples,
              theoretical_efficiency = theoretical_efficiency,
              empirical_efficiency = empirical_efficiency))
}
