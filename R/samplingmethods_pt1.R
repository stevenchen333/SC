#' Plot Sampling Result
#'
#' This function plots the comparison between the theoretical target PDF
#' and the empirical distribution of the samples generated using different sampling methods.
#'
#' @param samples A numeric vector of samples generated by any of the sampling methods (e.g., Inverse CDF, Box-Muller, Accept-Reject, MCMC).
#' @param target_pdf A function representing the target probability distribution (used for comparison).
#' @param from The lower bound of the x-axis (optional).
#' @param to The upper bound of the x-axis (optional).
#' @param main The main title of the plot.
#' @examples
#' # Define target PDF (Standard Normal Distribution)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Generate samples using Inverse CDF Sampling (Exponential Distribution)
#' samples <- inverse_cdf_sampling(1000, function(u) -log(1 - u))
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(samples, target_pdf)
#'
#' @export
plot_sampling <- function(samples, target_pdf, from = -4, to = 4, main = "Sampling vs Theoretical PDF") {
  # Plot the target PDF (theoretical distribution)
  curve(target_pdf(x), from = from, to = to, col = "blue", lwd = 2, main = main, ylim = c(0, 1))

  # Plot the histogram of the sampled values
  hist(samples, probability = TRUE, breaks = 30, col = "lightblue", add = TRUE, density = 30, border = NA)

  # Add a legend
  legend("topright", legend = c("Target PDF", "Sampled PDF"), col = c("blue", "lightblue"), lwd = 2)
}

#------------------------------------

#' Plot Contour Plot for 2D Samples
#'
#' This function plots a contour plot of the target PDF and overlays the sampled points
#' in a 2D space, comparing the theoretical PDF and the sample distribution.
#'
#' @param samples A data frame or matrix with 2 columns representing the 2D sampled points.
#' @param target_pdf A function representing the target 2D probability distribution (used for comparison).
#' @param from The lower bound for the x-axis (optional).
#' @param to The upper bound for the x-axis (optional).
#' @param n_contour The number of contour levels.
#' @param main The title of the plot.
#' @examples
#' # Custom 2D density function
#' density <- function(x, y) {
#'   return(2 * (1 - x) * (1 - y) * (1 - x * y)^(-3))
#' }
#'
#' # Generate 2D samples using the provided sampling method
#' generate_samples <- function(n) {
#'   x_samples <- numeric(n)
#'   y_samples <- numeric(n)
#'   for (i in 1:n) {
#'     y_samples[i] <- runif(1)
#'     u <- runif(1)
#'     x_samples[i] <- (sqrt(u) - 1) / (y_samples[i] * sqrt(u) - 1)
#'   }
#'   return(data.frame(x = x_samples, y = y_samples))
#' }
#'
#' # Generate 1000 samples
#' samples_2d <- generate_samples(1000)
#'
#' # Plot the contour plot comparing the target PDF and sampled points
#' plot_2d_sampling(samples_2d, density)
#'
#' @export
plot_2d_sampling <- function(samples, target_pdf, from = 0, to = 0.99, n_contour = 30, main = "2D Sampling vs Theoretical PDF") {
  # Create a fine grid for plotting
  grid_size <- 100
  x_vals_fine <- seq(from, to, length.out = grid_size)
  y_vals_fine <- seq(from, to, length.out = grid_size)

  # Compute the target PDF on the grid
  z_matrix_fine <- matrix(0, length(x_vals_fine), length(y_vals_fine))
  for (i in 1:length(x_vals_fine)) {
    for (j in 1:length(y_vals_fine)) {
      z_matrix_fine[i, j] <- target_pdf(x_vals_fine[i], y_vals_fine[j])
    }
  }

  # Cap the values for better visualization
  z_matrix_capped <- pmin(z_matrix_fine, 5)

  # Prepare the data for plotting
  df <- expand.grid(x = x_vals_fine, y = y_vals_fine)
  df$z <- c(z_matrix_capped)

  # Plot using ggplot2
  ggplot(df, aes(x = x, y = y)) +
    geom_point(aes(size = z, color = z), alpha = 0.9) +
    scale_color_gradientn(colors = c("darkgreen", "olivedrab", "yellow", "orange", "red3")) +
    scale_size(range = c(0.5, 6)) +
    coord_cartesian(xlim = c(from, to), ylim = c(from, to)) +
    theme(legend.position = "none") +
    geom_contour(aes(x = x, y = y, z = z), color = "darkslategray", size = 0.5) +
    geom_point(data = samples, aes(x = x, y = y), alpha = 0.7, pch = 16) +
    ggtitle(main)
}


#------------------------------------

#' Inverse CDF Sampling
#'
#' This function generates random samples from a given continuous probability distribution
#' using the inverse cumulative distribution function (CDF) method.
#'
#' @param n The number of samples to generate.
#' @param inv A function representing the inverse CDF of the target distribution.
#' @return A numeric vector of sampled values.
#' @examples
#' # Define the inverse CDF for an Exponential Distribution
#' inv_cdf_exp <- function(u) { -log(1 - u) }
#'
#' # Generate 1000 samples using Inverse CDF Sampling
#' samples <- inv_cdf(inv_cdf_exp, n = 1000)
#'
#' # Plot the comparison between the exponential PDF and sampled values
#' plot_sampling(samples, function(x) dexp(x))  # Compare with exponential PDF
#'
#' @export
inv_cdf <- function(inv, n = 100000) {
  u <- runif(n)  # Generate uniform samples in (0,1)
  inv(u)     # Apply inverse CDF to transform uniform samples
}

#------------------------------------

#' Box-Muller Normal Sampling
#'
#' This function generates random samples from a standard normal distribution
#' using the Box-Muller transform.
#'
#' @param n The number of samples to generate (must be even for full pairs).
#' @return A numeric vector of sampled values from N(0,1).
#' @examples
#' # Generate 1000 samples using the Box-Muller transform
#' samples <- box_muller(1000)
#'
#' # Plot the comparison between the normal PDF and sampled values
#' plot_sampling(samples, function(x) dnorm(x))  # Compare with normal PDF
#'
#' @export
box_muller <- function(n = 100000) {
  if (n %% 2 == 1) stop("n must be even for full pairs.")

  u1 <- runif(n / 2)
  u2 <- runif(n / 2)

  r <- sqrt(-2 * log(u1))
  theta <- 2 * pi * u2

  z1 <- r * cos(theta)
  z2 <- r * sin(theta)

  return(c(z1, z2))  # Return the combined vector of normal samples
}



#------------------------------------

#' Accept-Reject Sampling with Efficiency Calculation
#'
#' This function generates samples from a target distribution using
#' the accept-reject sampling method and calculates both the **theoretical**
#' and **empirical efficiency**.
#'
#' @param proposal A function representing the probability density function (PDF) of the proposal distribution.
#' @param target A function representing the probability density function (PDF) of the target distribution.
#' @param M A constant such that target_pdf(x) <= M * proposal_pdf(x) for all x.
#' @param n The number of samples to generate.
#' @return A list containing:
#'   - `samples`: A numeric vector of accepted samples.
#'   - `theoretical_efficiency`: Theoretical efficiency (acceptance probability).
#'   - `empirical_efficiency`: Empirical efficiency (based on actual samples).
#' @examples
#' # Define the proposal PDF (Uniform(-3, 3) PDF)
#' proposal_pdf <- function(x) { ifelse(x >= -3 & x <= 3, 1/6, 0) }
#'
#' # Define the target PDF (Standard Normal PDF)
#' target_pdf <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Compute constant M
#' M <- max(dnorm(seq(-3, 3, length.out = 100)) / proposal_pdf(seq(-3, 3, length.out = 100)))
#'
#' # Perform Accept-Reject Sampling with efficiency calculation
#' result <- accept_reject(proposal_pdf, target_pdf,
#'                                   M, 1000)
#'
#' # Plot the comparison between target PDF and sampled PDF
#' plot_sampling(result$samples, target_pdf)
#'
#' # Print the theoretical efficiency (acceptance probability)
#' result$theoretical_efficiency
#'
#' # Print the empirical efficiency (based on actual samples)
#' result$empirical_efficiency
#'
#' @export
accept_reject <- function(proposal, target, M = NULL, n = 100000, lower = NULL, upper = NULL) {
  samples <- numeric(n)  # To store the accepted samples
  count <- 0  # Counter for accepted samples
  total_proposed <- 0  # Counter for proposed samples

  # Ratio function to calculate the target-to-proposal ratio
  ratio_function <- function(x) {
    target(x) / proposal(x)
  }

  # If M is not provided, optimize to find the maximum of the ratio function
  if (is.null(M)) {
    if (is.null(lower) | is.null(upper)) {
      stop("You must provide bounds for optimization if M is not supplied.")
    }
    M <- optimise(ratio_function, lower = lower, upper = upper, maximum = TRUE, tol = 0.00001)$objective
  }

  while (count < n) {
    x <- proposal(1)  # Draw a sample from the proposal distribution
    u <- runif(1)  # Uniform(0,1) sample
    total_proposed <- total_proposed + 1

    # Acceptance condition
    if (u <= (target(x) / (M * proposal(x)))) {
      count <- count + 1
      samples[count] <- x
    }
  }

  # Theoretical efficiency: ratio of acceptance probabilities
  theoretical_efficiency <- 1 / M

  # Empirical efficiency: ratio of accepted samples to proposed samples
  empirical_efficiency <- n / total_proposed

  return(list(samples = samples,
              theoretical_efficiency = theoretical_efficiency,
              empirical_efficiency = empirical_efficiency))
}



#------------------------------------
#' Metropolis Algorithm (Supports Optional Metropolis-Hastings)
#'
#' This function implements the Metropolis algorithm for sampling from a given target distribution.
#' Currently, Metropolis-Hastings is not implemented, but the function structure allows future extension.
#'
#' @param target A function representing the target distribution (unnormalized density).
#' @param initial A function that generates the initial sample.
#' @param proposal A function that proposes a new sample given the current sample.
#' @param n Integer, number of iterations for the algorithm. Default is 100000.
#' @param hastings Logical, whether to use Metropolis-Hastings. Currently, only Metropolis is implemented. Default is FALSE.
#'
#' @return A list containing the sampled values.
#'
#' @examples
#' # Define target distribution (unnormalized density)
#' target <- function(x) { dnorm(x, mean = 0, sd = 1) }
#'
#' # Define proposal function (Normal random walk)
#' proposal <- function(x) { rnorm(1, mean = x, sd = 1) }
#'
#' # Define initial value function
#' initial <- function() { 0 }
#'
#' # Run Metropolis algorithm
#' samples <- metropolis(target, initial, proposal, n = 10000, hastings = FALSE)
#'
#' # Plot the histogram of samples
#' hist(unlist(samples), probability = TRUE, main = "Metropolis Samples",
#'      xlab = "x", col = "lightblue", border = "black")
#'
#' @export
metropolis <- function(target, initial, proposal, n = 100000, hastings = FALSE){
  samples <- list(initial())

  for (i in 1:n) {
    current <- samples[[length(samples)]]
    proposed <- proposal(current)

    if (hastings == FALSE){
      if (runif(1) < target(proposed) / target(current)) {
        samples <- append(samples, list(proposed))
      } else {
        samples <- append(samples, list(current))
      }

    }

    if (hastings == TRUE){
      NULL
    }
  }

  return(samples)

}

#------------------------------------
#' Gibbs Sampler for Multivariate Distributions with Thinning
#'
#' Implements a Gibbs sampling algorithm for an `n_dim`-dimensional random variable.
#' Includes a thinning option to reduce autocorrelation, while ensuring `n` samples
#' are retained after burn-in and thinning.
#'
#' @param n_dim Integer. The number of dimensions (variables) in the distribution.
#' @param n_iter Integer. The total number of iterations to run the sampler.
#' @param burn_in Integer. The number of initial samples to discard (burn-in period).
#' @param thinning Integer. The thinning interval, specifying how frequently to keep a sample.
#'   Default is 1, meaning no thinning.
#' @param init Numeric vector of length `n_dim`. The starting values for the sampler.
#' @param conditional_samplers List of functions. Each function corresponds to a conditional
#'   sampler for one of the dimensions, taking the current state as input and returning a new value.
#'
#' @return A matrix of size `(n)` containing the sampled values after the burn-in period and thinning.
#' @examples
#' set.seed(123)
#'
#' # Define conditional samplers for a bivariate normal distribution
#' mu1 <- 0; mu2 <- 0
#' sigma1 <- 1; sigma2 <- 1
#' rho <- 0.8
#'
#' cond_sampler_x <- function(state) {
#'   y <- state[2]
#'   rnorm(1, mean = mu1 + rho * (y - mu2) * sigma1 / sigma2, sd = sqrt((1 - rho^2) * sigma1^2))
#' }
#'
#' cond_sampler_y <- function(state) {
#'   x <- state[1]
#'   rnorm(1, mean = mu2 + rho * (x - mu1) * sigma2 / sigma1, sd = sqrt((1 - rho^2) * sigma2^2))
#' }
#'
#' # Run Gibbs sampler with thinning every 30 iterations and retain 500 samples
#' samples <- gibbs_sampler(n_dim = 2, n_iter = 10000, burn_in = 1000, thinning = 30,
#'                          init = c(0, 0), conditional_samplers = list(cond_sampler_x, cond_sampler_y))
#'
#' # Plot the samples
#' plot(samples, col = rgb(0, 0, 1, 0.2), pch = 16, main = "Gibbs Sampler Samples with Thinning")
#'
#' @export
gibbs_sampler <- function(n_dim, n_iter, burn_in, thinning = 1, init, conditional_samplers) {
  if (burn_in >= n_iter) {
    stop("Burn-in period must be smaller than the total number of iterations.")
  }

  if (thinning < 1) {
    stop("Thinning interval must be at least 1.")
  }

  # Initialize the samples matrix
  samples <- matrix(NA, nrow = n_iter, ncol = n_dim)
  samples[1, ] <- init

  # Perform Gibbs sampling
  for (i in 2:n_iter) {
    current_sample <- samples[i - 1, ]
    for (j in 1:n_dim) {
      current_sample[j] <- conditional_samplers[[j]](current_sample)
    }
    samples[i, ] <- current_sample
  }

  # Discard burn-in samples
  samples <- samples[(burn_in + 1):n_iter, , drop = FALSE]

  # Calculate the number of samples to retain after thinning
  n_samples_needed <- floor((n_iter - burn_in) / thinning)

  # If thinning results in fewer than desired samples, adjust the thinning interval
  if (n_samples_needed > 0) {
    # Get the indices after thinning
    retained_indices <- seq(1, nrow(samples), by = thinning)

    # Ensure we do not exceed the number of needed samples
    if (length(retained_indices) > n_samples_needed) {
      retained_indices <- retained_indices[1:n_samples_needed]
    }

    # Subset the samples based on the retained indices
    samples <- samples[retained_indices, , drop = FALSE]
  }

  return(samples)
}



